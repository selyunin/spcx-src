/*
 * scalar_with_infinity.h
 *
 *  Created on: Nov 23, 2009
 *      Author: frehse
 */

#ifndef SCALAR_WITH_INFINITY_H_
#define SCALAR_WITH_INFINITY_H_

#include <iostream>
#include <algorithm>
#include <boost/operators.hpp>
#include "math/type_conversion.h"

template<class T>
class scalar_with_infinity // note: private inheritance is OK here!
: boost::addable<
		scalar_with_infinity<T> // scalar_with_infinity + scalar_with_infinity
		,
		boost::subtractable<scalar_with_infinity<T> // scalar_with_infinity - scalar_with_infinity
				, boost::dividable<scalar_with_infinity<T> // point / T
						, boost::multipliable<scalar_with_infinity<T> // point * T, T * point
								, boost::equality_comparable<
										scalar_with_infinity<T> ,
										boost::partially_ordered<
												scalar_with_infinity<T> > > > > > > {
public:
	enum number_type {
		FINITE, POS_INFTY, NEG_INFTY, NOTANUMBER
	};

	scalar_with_infinity() :
		my_nt(NOTANUMBER) {
	}
	;

	/** Instantiate a scalar_with_infinity from a class that is
	 * convertible to T. */
	template<class S>
	explicit scalar_with_infinity(S t, number_type nt = FINITE) {
		*this = scalar_with_infinity<T> (T(t), nt);
	}
	;

	/** Instantiate a scalar_with_infinity from a scalar T and with
	 * number_type nt. If unspecified, nt=FINITE.
	 *
	 * @note Internally, my_val=0 unless nt=FINITE.
	 */
	explicit scalar_with_infinity(T t, number_type nt = FINITE) {
		my_nt = nt;
		switch (my_nt) {
		case FINITE:
			my_val = t;
			break;
		case POS_INFTY:
			set_pos_infty();
			break;
		case NEG_INFTY:
			set_neg_infty();
			break;
		case NOTANUMBER:
			set_NaN();
			break;
		}
	}
	;

	/** Obtain a finite value. Throws if *this is not finite. */
	const T& get_val() const {
		if (!is_finite())
			throw std::runtime_error(
					"scalar_with_infinity : requested finite from not-finite");
		return my_val;
	}
	;

	number_type get_type() const {
		return my_nt;
	}
	;

	bool is_finite() const {
		return my_nt == FINITE;
	}
	;

	bool is_zero() const {
		return is_finite() && my_val == T(0);
	}
	;

	bool is_pos() const {
		return (is_finite() && my_val > T(0)) || is_pos_infinity();
	}
	;

	bool is_neg() const {
		return (is_finite() && my_val < T(0)) || is_neg_infinity();
	}
	;

	bool is_infinity() const {
		return my_nt == POS_INFTY || my_nt == NEG_INFTY;
	}
	;

	bool is_pos_infinity() const {
		return my_nt == POS_INFTY;
	}
	;

	bool is_neg_infinity() const {
		return my_nt == NEG_INFTY;
	}
	;

	bool is_NaN() const {
		return my_nt == NOTANUMBER;
	}
	;

	scalar_with_infinity& operator+=(const scalar_with_infinity& s) {
		switch (my_nt) {
		case FINITE:
			if (s.is_finite())
				my_val += s.my_val;
			else
				*this = s;
			break;
		case POS_INFTY:
			if (!(s.is_finite() || s.is_pos_infinity()))
				set_NaN();
			break;
		case NEG_INFTY:
			if (!(s.is_finite() || s.is_neg_infinity()))
				set_NaN();
			break;
		case NOTANUMBER:
			break;
		}
		return *this;
	}
	;
	// scalar_with_infinity operator+(scalar_with_infinity, const scalar_with_infinity&) automatically
	// generated by addable.

	scalar_with_infinity& operator-=(const scalar_with_infinity& s) {
		switch (my_nt) {
		case FINITE:
			if (s.is_finite())
				my_val -= s.my_val;
			else
				*this = s;
			break;
		case POS_INFTY:
			if (!(s.is_finite() || s.is_neg_infinity()))
				set_NaN();
			break;
		case NEG_INFTY:
			if (!(s.is_finite() || s.is_pos_infinity()))
				set_NaN();
			break;
		case NOTANUMBER:
			break;
		}
		return *this;
	}
	;
	// scalar_with_infinity operator-(scalar_with_infinity, const scalar_with_infinity&) automatically
	// generated by subtractable.

	scalar_with_infinity& operator*=(const scalar_with_infinity& s) {
		if (is_NaN() || s.is_NaN()) {
			set_NaN();
		} else if (is_finite()) {
			if (s.is_infinity()) {
				scalar_with_infinity s_temp = s;
				s_temp.multiply_with_sign(*this);
				std::swap(*this, s_temp);
			} else {
				my_val *= s.my_val;
			}
		} else if (s.is_finite()) {
			multiply_with_sign(s);
		} else if (s.is_neg_infinity()) {
			negate();
		}
		return *this;
	}
	;

	scalar_with_infinity& operator/=(const scalar_with_infinity& s) {
		if (is_NaN() || s.is_NaN()) {
			set_NaN();
		} else if (is_finite()) {
			if (s.is_infinity()) {
				set_zero();
			} else if (s.is_zero()) {
				set_NaN();
			} else {
				my_val /= s.my_val;
			}
		} else if (s.is_finite()) {
			multiply_with_sign(s);
		} else {
			set_NaN();
		}
		return *this;
	}
	;

	bool operator==(const scalar_with_infinity& s) const {
		return my_nt == s.my_nt && my_val == s.my_val;
	}
	;

	void negate() {
		switch (my_nt) {
		case FINITE:
			my_val = -my_val;
			break;
		case POS_INFTY:
			my_nt = NEG_INFTY;
			break;
		case NEG_INFTY:
			my_nt = POS_INFTY;
			break;
		case NOTANUMBER:
			break;
		}
	}

	static scalar_with_infinity pos_infty() {
		return scalar_with_infinity<T> (T(0), POS_INFTY);
	}

	static scalar_with_infinity neg_infty() {
		return scalar_with_infinity<T> (T(0), NEG_INFTY);
	}

	static scalar_with_infinity NaN() {
		return scalar_with_infinity<T> (T(0), NOTANUMBER);
	}

	static scalar_with_infinity zero() {
		return scalar_with_infinity<T> (T(0), FINITE);
	}

private:
	void set_NaN() {
		my_val = T(0);
		my_nt = NOTANUMBER;
	}
	;

	void set_zero() {
		my_val = T(0);
		my_nt = FINITE;
	}
	;

	/** Assign to *this sign(s)*(*this). */
	void multiply_with_sign(const scalar_with_infinity& s) {
		if (!is_NaN()) {
			if (s.is_zero()) {
				set_NaN();
			} else if (s.is_neg()) {
				negate();
			}
		}
	}
	;
	void set_pos_infty() {
		my_val = T(0);
		my_nt = POS_INFTY;
	}
	;
	void set_neg_infty() {
		my_val = T(0);
		my_nt = NEG_INFTY;
	}
	;
	T my_val;
	number_type my_nt;
};

template<class T>
bool operator<(const scalar_with_infinity<T>& s1,
		const scalar_with_infinity<T>& s2) {
	if (s1.is_neg_infinity() && (s2.is_finite() || s2.is_pos_infinity())) {
		return true;
	} else if (s2.is_pos_infinity() && s1.is_finite()) {
		return true;
	} else if (s1.is_finite() && s2.is_finite()) {
		return s1.get_val() < s2.get_val();
	} else {
		return false;
	}
}
;

template<class T>
scalar_with_infinity<T> operator-(scalar_with_infinity<T> s) {
	s.negate();
	return s;
}
;

/** Specialization to get the scalar back from the annotated scalar.
 * Throws if called for a non-finite value. */
template<typename result_type>
class converter<result_type, scalar_with_infinity<result_type> > {
public:
	static result_type convert(const scalar_with_infinity<result_type>& x) {
		return x.get_val();
	}
	;
};

template<>
class converter<__float128,scalar_with_infinity<__float128> > {
public:
	static __float128 convert(const scalar_with_infinity<__float128>& x) {
		return x.get_val();
	}
	;
};

/** Specialization to create an annotated scalar. */
template<typename scalar_type>
class converter<scalar_with_infinity<scalar_type> , scalar_type> {
public:
	static scalar_with_infinity<scalar_type> convert(const scalar_type& x) {
		return scalar_with_infinity<scalar_type> (x);
	}
	;
};

template<typename scalar_type>
std::ostream& operator<<(std::ostream& os, const scalar_with_infinity<
		scalar_type>& r) {
	if (r.is_NaN())
		os << "NaN";
	else if (r.is_pos_infinity())
		os << "pos_infty";
	else if (r.is_neg_infinity())
		os << "neg_infty";
	else
		os << r.get_val();
	return os;
}

#endif /* SCALAR_WITH_INFINITY_H_ */
